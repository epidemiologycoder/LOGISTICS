* Create library to indicate where your datasets are stored;
LIBNAME EPI5345 '/folders/myshortcuts/SAS_windows/myfolders/LOGISTIC';

goptions reset=all; * Resets all graph options to default values;

data ready;
 set epi5345.wcgs;
 if chol=645 then delete;
 * The following 4 lines create scaled continuous variables to match textbook example (see below);
 age_10=age/10; 
 chol_50=chol/50;
 bmi_10=bmi/10;
 sbp_50=sbp/50;
 if smoke=2 then smoked=1;
 else if smoke=1 then smoked=0;
 if dibpat="A1,A2" then dibpatd=1;
 else if dibpat="B3,B4" then dibpatd=0;
 if chd69="yes" then chd69d=1;
 else if chd69="no" then chd69d=0;
 if arcus="present" then arcusd=1;
 else if arcus="absent" then arcusd=0;
 else arcusd=.;
run;

* LR test for goodness-of-fit;
proc logistic data=ready;
 class smoke (ref="1") behpat (ref="B4") / param=ref;
 model chd69 (event="yes")=chol age sbp weightkg smoke behpat / scale=none aggregate;
run;

* LR test compa ring two nested models - Example from textbook behpat vs. dibpat;
proc logistic data=ready;
 model chd69 (event='yes')=age_10 chol_50 sbp_50  bmi_10 smoke / scale=none aggregate;
run;
proc logistic data=ready;
 class behpat (ref='A1');
 model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke behpat / scale=none aggregate;
run;
proc logistic data=ready;
 class dibpat;
 model chd69 (event='yes')=age_10 chol_50 sbp_50  bmi_10 smoke dibpat / scale=none aggregate;
run;
* Compare D2-D1 to chi-square distribution;
 data chipvalue;
  pvalue=1-probchi(24.533,1);
  crit=cinv(0.95,1);
 run;
 proc print data=chipvalue noobs;
 run;

* Another likelihood ratio test example for the significance of the 4-category behavioural pattern variable;
* Optional - Can also do it the same way as above;
* We can use proc genmod to get a LR test;
proc genmod data=ready;
 class behpat (ref="B4") / param=ref;
 model chd69 (event="yes")=age_10 chol_50 sbp_50 bmi_10 smoke behpat / dist=bin link=logit;
 contrast 'lrt behpat' behpat 1 0 0,
                       behpat 0 1 0,
                       behpat 0 0 1;
run;

* Hosmer-Lemeshow test;
 proc logistic data=ready;
  class dibpat;
  model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke dibpat / lackfit;
 run;
 proc logistic data=ready;
  class dibpat (ref="B3,B4") / param=ref;
  model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke dibpat / lackfit;
 run;

* Area under the ROC curve;
proc logistic data=ready;
 class dibpat;
 model chd69 (event='yes')=age_10 sbp_50 chol_50 bmi_10 smoke dibpat / outroc=chdroc;
run;
* Separate plot of ROC curve;
proc gplot data=chdroc;
 plot _SENSIT_*_1MSPEC_;
run;
quit;

* Regression diagnostics;
proc logistic data=ready;
 class dibpat (ref='B3,B4') smoke (ref='1') / param=ref;
 model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke dibpat / influence; * outputs the observation number, the independent variables and diagnostic statistics;
 output out=chddiag stdreschi=stdreschi reschi=reschi stdresdev=stdresdev resdev=resdev p=predchd dfbeta=_all_ difchisq=difchisq difdev=difdev h=leverage c=c cbar=cbar;
run;
proc logistic data=ready;
 class dibpat (ref='B3,B4') smoke (ref='1') / param=ref;
 model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke dibpat / iplots; * iplots requests automatic index plots;
 output out=chddiag stdreschi=stdreschi reschi=reschi stdresdev=stdresdev resdev=resdev p=predchd dfbeta=_all_ difchisq=difchisq difdev=difdev h=leverage c=c cbar=cbar;
run;
proc logistic data=ready plots(only label)=(phat leverage dpc); * can specify specific plots with the plots option (see documentation). label requests the observation numbers on plots;
 class dibpat (ref='B3,B4') smoke (ref='1') / param=ref;
 model chd69 (event='yes')=age_10 chol_50 sbp_50 bmi_10 smoke dibpat;
run;

* Some examples of plots with gplot;
* Index plot of standardized Pearson residuals;
* Creates index variable. _n_ is the SAS syntax for obs number;
data chddiag1;
 set chddiag;
 obsno=_n_;
run;
proc gplot data=chddiag1;
 plot stdreschi*obsno;
run;
quit;
* Plot of standardized Pearson residuals against fitted values;
proc gplot data=chddiag;
 plot stdreschi*predchd;
run;
quit;
* Plot of DIFCHISQ against fitted values;
proc gplot data=chddiag;
 plot difchisq*predchd;
run;
quit;
* Plot of DFBETA for bmi_10 against fitted values;
proc gplot data=chddiag;
 plot dfbeta_bmi_10*predchd;
run;
quit;
* Print outlier from the DFBETA graph;
data outlier;
  set chddiag;
  if dfbeta_bmi_10>0.25;
run;
proc print data=outlier;
 var id chd69 age sbp bmi_10 dfbeta_bmi_10 predchd chd69;      
run;

* Check collinearity;
* In raw predictors;
ods select ParameterEstimates CollinDiag CollinDiagNoInt;
proc reg data=ready;
 model chd69d=age_10 sbp_50 chol_50 bmi_10 smoked dibpatd / collin collinoint vif tol;
run; quit;
* In weighted predictors;
proc genmod data=ready;
 model chd69d=age_10 sbp_50 chol_50 bmi_10 smoked dibpatd / dist=bin scoring=50 corrb;
 output out=out hesswgt=w;
run;
ods select ParameterEstimates CollinDiag CollinDiagNoInt;
proc reg data=out;
 weight w;
 model chd69d=age_10 sbp_50 chol_50 bmi_10 smoked dibpatd / collin collinoint vif tol;
run; quit;  


* Three approaches to check linearity;
* 1. Approach using proc loess;
proc sort data=ready;
 by age;
run;
proc loess data=ready;
 ods output OutputStatistics=loeschd;
 model chd69d=age / smooth=0.3; * The direct option requests automatic selection of the smoothing factor. change it to smooth=0.8, for example, to control the smoothing;
run; 
* Plot the logit separately;
data loeschd;
 set loeschd;
 logit=log(pred/(1-pred));
run;
symbol1 interpol=j;
proc gplot data=loeschd;
 plot logit*age;
run;
quit;

* 2. Other approach: Get frequencies of outcome for each unique age value and logit of empirical probability of outcome;
***** IMPORTANT NOTE: This method only works when many observations have the same value of continuous variable for all values;
***** If there unique values of the continuous variable, use approach described above or below;
proc freq data=ready;
 tables chd69*age / noprint out=agefreq;
run;
proc sort data=agefreq;
 by age chd69;
run;
data logitage (keep=age logit);
 retain tot;
 set agefreq;
 by age;
 if first.age then tot=COUNT;
 if last.age then do;
  pr=count/(tot+count);
  logit=log(pr/(1-pr));
  output;
 end;
run;
* Plot the LOWESS smoother of this empirical logit vs. age relationship;
proc sgplot data=logitage;
 loess x=age y=logit / smooth=0.3; * If you dont specify the smooth option it will be selected automatically;
run;
quit;
proc sgplot data=logitage;
 loess x=age y=logit / smooth=0.8;
run;
quit;


* 3. Another way of checking linearity by categorizing the continuous variable in many categories;
* First categorize age by percentiles or deciles or other meaningful number of categories depending on your dataset;
* groups=100 specifies percentiles, out=agecat outputs the results in the agecat dataset;
* age is replaced by percentile in the output dataset;
proc rank data=ready groups=50 out=agecat;
 var age;
run;
* Get frequencies in each outcome - cdh69 - age category;
proc freq data=agecat;
 tables chd69*age / noprint out=agefreq;
run;
* Sort by age and outcome to calculate logit in data step below - you need to sort when you set a dataset by;
proc sort data=agefreq;
 by age chd69;
run;
* Calculate proportion of events (chd69=yes) in each age category and then the logit=log(odds);
data logitage (keep=age logit);
 retain tot;
 set agefreq;
 by age;
 if first.age then tot=COUNT; * tot stores the frequency stored in the variable COUNT, here for chd69=no;
 if last.age then do; * here chd69=yes so we define...;
  pr=count/(tot+count); *the proportion pr as count (number of chd69=yes in this age cat/total;
  logit=log(pr/(1-pr)); * the logit;
  output;
 end;
run;
* Plot the logit vs. age percentiles and assess the linearity visually;
goptions reset=all;
proc gplot data=logitage;
 plot logit*age;
run;
quit;
* Or add a linear regression line to help you assess linearity using the interpolation option;
symbol1 interpol=R value=circle; 
proc gplot data=logitage;
 plot logit*age / regeqn; * regeqn displays the equation for the regression line;
run;
quit;
* Or try a cubic regression analysis with confidence interval lines also using the interpolation option;
symbol1 interpol=rcclm95 value=circle; 
proc gplot data=logitage;
 plot logit*age / regeqn; * regeqn displays the equation for the regression line;
run;
quit;
* Or you can use a smoother on these data - the output is easier to understand than the loess procedure;
proc sgplot data=logitage;
 loess x=age y=logit / smooth=0.8; * If you dont specify the smooth option it will be selected automatically;
run;
quit;
proc sgplot data=logitage;
 loess x=age y=logit / smooth=0.3; 
run;
quit;


* Investigate a quadratic term, centering age first;
proc means data=ready;
 var age;
run;
data ready;
 set ready;
 agec=age-46.3;
run;
proc logistic data=ready;
  model chd69 (event='yes')=agec agec*agec;
run;


